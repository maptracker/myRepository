## The file should include a library reference to your pacakge
## and any other packages needed to run the tests
library("<NAME>")

## This file should not interfere with your package, but you really should
## delete it before submitting the package to a repository, or move it
## somewhere for reference.

### More help: http://r-pkgs.had.co.nz/tests.html
## Or, library("testthat"), type ?expect_ and hit tab to see completions

## These tests will be automatically run when you call buildAndCheck()
## You can make as many test files here as you like, just name them
##     test-SomethingVaguelyDescriptive.R

## Good practice is to make tests while you generate code. This does
## have a time cost associated with it; If you feel that approach is
## too onerous, an alternative is to write a test for each problem you
## actually encounter. For example, suppose a change to function foo()
## inadvertently left out 'drop=FALSE', resulting in the generation of
## vectors in some cases. Even once you've patched the problem, it's
## advisable at that point to add some tests for a few edge cases
## around foo() that verify the outputs are matrices.

# In general, you will have a block of format
## test_that("descriptive text, { # block of code })

test_that("Description of what is being tested goes here", {

    ## Most of the tests include an optional "info" parameter that can be
    ## used to describe the test taking place. Supposedly these snippets are
    ## included in testing output when a test fails, to help identify the
    ## source of the discrepancy. I have not seen them show up in that
    ## context, however. They can still serve as useful comments, so you
    ## may wish to include them.

    ## NOTE: You should also explicitly parmeterize the info field
    ## with 'info='. This is because many of the expect_ methods
    ## include dots (...) in the call, and sometimes misinterpret a
    ## 'naked' (no param key=) info string as something else.

    ## You can make any objects needed for testing here
    foo <- 1:10

    ## expect_identical is REALLY identical. 10 != 10L
    expect_identical(length(foo), 10L, info="Validate length of foo")

    fooMat <- matrix(1:9, nrow=3)

    ## Type checks
    expect_type(fooMat, "integer") # Does not have info parameter
    expect_is(fooMat, "matrix", info="Should be a matrix")

    bar <- 1:10
    attr(bar,"color") <- "fuschia"

    ## Attributes are also compared in expect_identical. If you wish to
    ## ignore them, use expect_equivalent instead
    expect_equivalent(bar, 1:10, info="Confirm bar is properly instantiated")

    ## Fairly simple tests. 
    weStartedTheFire   <- FALSE
    itWasAlwaysBurning <- TRUE
    whenBurning        <- "since the world was turning"
    edsel              <- NULL
    chorus             <- 1:6

    expect_false(weStartedTheFire, info="Validate causation flag")
    expect_true(itWasAlwaysBurning, info="Confirm prior state")
    expect_match(whenBurning, "world",
                 info="Reported values vary, general match")
    ## Must test for NULL as expect_null, not expect_identical
    expect_null(edsel, info="Variable should be undefined at this point")
    expect_length(chorus, 6) # Huh - info not allowed!

    ## You can check that a message is generated by an expression
    sneeze <- function ( bless=TRUE ) {if (bless) message("Gesundheit!")}
    expect_message(sneeze())
    ## And can optionally check that it matches a string
    expect_message(sneeze(), "gesund", ignore.case = TRUE)
    ## Also check there is NO message
    expect_silent(sneeze(bless=FALSE))

    ## Check for presence of names on object, and optionally specific names
    myNames <- c("alpha", "beta", "gamma")
    baz     <- setNames(1:3, myNames)
    expect_named(baz)
    expect_named(baz, myNames)


})
